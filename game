/***********************************************************/
// 다음은 사용자 함수를 호출하는 루틴임 지우지 말것!
/***********************************************************/

#include "device_driver.h"
#include "math.h"
#include "2440addr.h"
#include <stdlib.h>
#define printf 	Uart_Printf

void User_Main(void);
typedef struct
{
int day;
int year;
int mon;
int date;
int hour;
int min;
int sec;
}RTC_TIME;

int RTC_Get_Time(void)
{
RTC_TIME a;

a.hour = (int)rBCDHOUR;
a.min = (int)rBCDMIN;
a.sec = (int)rBCDSEC;
return ((a.hour >> 4) & 0xf) * 10 + (a.hour & 0xf) * 360 + \
((a.min >> 4) & 0xf) * 10 + (a.min & 0xf) * 60 + \
((a.sec >> 4) & 0xf) * 10 + (a.sec & 0xf);

}
void Main(void)
{
	MMU_Init();
	Led_Init();
	Key_Poll_Init();
	Uart_Init(115200);
	Timer0_Init();
	Timer3_Buzzer_Init();
	Timer4_Init();
	Lcd_Graphic_Init();
	Lcd_Clr_Screen(0xf800);

	Uart_Printf("Welcome GBOX World!\n");
	User_Main();
	Uart_Printf("Good Bye~\n");
}

/*===== << 여기부터 사용자 프로그램을 작성함 >> =====*/



#include "./Image/start.h"
#include "./Image/ins2.h"
#include "./Image/basket.h"
#include "./Image/basket2.h"
#include "./Image/vege.h"
#include "./Image/ins1.h"
#include "./Image/level1.h"
#include "./Image/nvege.h"
#include "./Image/bomb.h"
#include "./Image/back.h"
#include "./Image/exp1.h"
#include "./Image/black.h"
#include "./Image/lv1.h"
#include "./Image/lv2.h"
#include "./Image/lv3.h"
#include "./Image/lv4.h"




const unsigned short * Disp[] = {vege, ins1, vege, nvege, vege, ins2, bomb, bomb};
const unsigned short * Disp2[] = {lv1, lv2, lv3, lv4};


/* 5:5:5:I Color Definition */

#define BLACK	0x0000
#define WHITE	0xfffe
#define BLUE	0x003e
#define GREEN	0x07c0
#define RED		0xf800
#define YELLOW	0xf7c0
#define PINK 	0xf8fe
void Draw_Basket1(void);
void Draw_Basket2(void);
void Move_Basket(int key);
void Move_Food(int time);
void Draw_Food(void);
void GameOver(void);
void Level(void);
void Game_Init();
void Exp_Game();
void Check1(int i);
void Check2(int i);
void User_Main(void)
{
	int xtmp, ytmp;
	int u;
	for(;;)
	{
		Lcd_Control_Brightness(5);
		Lcd_Select_Buffer_Mode(LAYER_MODE);
	 	Lcd_Select_Draw_Frame_Buffer(0);
	 	Lcd_Select_Display_Frame_Buffer(0);
	 	Lcd_Clr_Screen(RED);
	    Lcd_Get_Info_BMP(&xtmp, &ytmp, start);
	    Lcd_Draw_BMP((160-(xtmp/2)), (120-(ytmp/2)), start);
		Lcd_Printf(120,100,YELLOW,RED,1,1,"VEGAN GAME");
		Lcd_Printf(90,130,WHITE,BLACK,1,1,"Game Start : Press 1");
		Lcd_Printf(85,150,WHITE,BLACK,1,1,"How to Play : Press 2");
					do{
							Led_Display(0x5);
							Timer4_Delay(100);
							Led_Display(0x6);
							Timer4_Delay(100);
						}while(!Key_Get_Pressed());
				u = Key_Wait_Key_Pressed ();
				switch(u) {
				case 5: Level(); break;
				case 6: Exp_Game(); break;
				}
	}
}

#define BACK_COLOR 	WHITE
#define WIDTH 		320
#define HEIGHT 		240
struct Basket
{
	int timer;
	int move_flag;
	int pos[2];
	int pos_init[2];
	int pos_back[2];
	int size[2];
	unsigned short color;
	int speed_step;
	int move_step;
};
struct Food
{
	int timer;
	int move_flag;
	int flag;
	int flag_new;
	int pos[2];
	int pos_back[2];
	int size[2];
	int image;
	int speed_step;
	int move_step;
}Ffood[4];
//unsigned int COLOR[] = {BLACK, GREEN, RED, YELLOW, WHITE};
struct Basket Bas = {0,1,{0,190},{0,190},{0,190}, {80, 30},BLACK, 4, 80};
int score = 3;
int lv_flag = 0;
int lv_cnt = 0;
int check[10] = {0};
int food_var[4] = {4,6,8,8};
int bas_right[4] = {0,0,40,40};
void Level(void) {
		srand(RTC_Get_Time());
		struct Food init = {0,1,0,0,{0,0},{0,0},{40,30}, 0, 6 - lv_cnt, 30}; // timer, move_flag, flag
		int key;
		int i, tmp;
		lv_flag = 0;
		score=3;
		volatile int time = 0;

		do{
					Lcd_Draw_BMP(0,0,Disp2[lv_cnt]);
			}while(!Key_Get_Pressed());


		for(i=0; i<10; i++) {
						check[i] = 0;
					}
		for(i=0; i<food_var[lv_cnt]/2;i++) {
			Ffood[i] = init;
			while(1) {
				tmp = rand()%food_var[lv_cnt];
				if(!check[tmp]) {
					check[tmp] = 1;
					Ffood[i].image = tmp;
					break;
				}
			}
			if(tmp >= 6) {
				Ffood[i].speed_step = 1;
			}

			Ffood[i].pos[0] = rand() % 8 * 40 ;

		}

		Game_Init();
		if(lv_cnt<=1) {
			Draw_Basket1(); // 처음 바구니 그리기
					for(;;) {
						if(Timer0_Check_Expired()) {
							time++;
							Move_Food(time);
							Draw_Food();
						}

							if(lv_flag) break;
							key = Key_Get_Pressed();
							if(key) {
								Move_Basket(key);
								Draw_Basket1();
								Key_Wait_Key_Released();
							}
					}
		}
		else if(lv_cnt>=2) { // 레벨 3,4
				Draw_Basket2(); // 처음 바구니 그리기
								for(;;) {
									if(Timer0_Check_Expired()) {
										time++;
										Move_Food(time);
										Draw_Food();
									}

										if(lv_flag) break;
										key = Key_Get_Pressed();
										if(key) {
											Move_Basket(key);
											Draw_Basket2();
											Key_Wait_Key_Released();
										}
								}

		}

		Level();


}
void Exp_Game(void) {
	Key_Wait_Key_Released();
	do{
		Lcd_Draw_BMP(0,0,exp1);
	}while(!Key_Get_Pressed());
	Key_Wait_Key_Released();
	Level();
}
void Move_Food(int time) {
	srand(RTC_Get_Time());
	int i, tmp;
	if(time==(5-lv_cnt)) {
		Ffood[0].flag = 1;
		Ffood[0].flag_new = 1;
	}
	else if(time%(5-lv_cnt) == 0) {
		Uart_Printf("%d", time);
		for(i=0; i<food_var[lv_cnt]/2; i++) {
			if(Ffood[i].flag == 0) {
				Ffood[i].timer = 0;
				Ffood[i].move_flag = 1;
				Ffood[i].flag_new = 1; //새로 생성된 food 구분하기
				Ffood[i].flag = 1;
				while(1) {
								tmp = rand()%food_var[lv_cnt];
								if(!check[tmp]) {
									check[tmp] = 1;
									Ffood[i].image = tmp;
									break;
								}
				}
				Ffood[i].pos[0] = Ffood[i].pos_back[0] = rand() % 8 * 40 ;
				Ffood[i].pos[1] = 0;
				check[i] = 0;
				break;
		}
	}
}
	for(i=0;i<food_var[lv_cnt]/2;i++) {
		if(Ffood[i].flag == 1) {
			Ffood[i].timer = time;
			if(Ffood[i].timer >= Ffood[i].speed_step) {
				Ffood[i].pos_back[0] = Ffood[i].pos[0] ;
				Ffood[i].pos_back[1] = Ffood[i].pos[1] ;
				if(Ffood[i].flag_new) {
					Ffood[i].flag_new = 0;
				}
				else Ffood[i].pos[1] = Ffood[i].pos[1] + Ffood[i].move_step;
				Ffood[i].move_flag = 1;
			}
		}
	}
}

void Draw_Food(void) {
	int i;
	for(i=0; i<food_var[lv_cnt]/2; i++) {
		if(Ffood[i].pos[1] >= 180) {
			if(lv_cnt>=3) {Check2(i);}
			else if(lv_cnt<=2) {Check1(i);}
			Ffood[i].pos[1] = 0;
			Lcd_Printf(70,225, YELLOW,BLACK, 1,1,"%d", score);
			if(score==10) {lv_cnt++; lv_flag=1; return;}
			if(score<0) GameOver();
			Ffood[i].flag=0;
			Lcd_Draw_Bar(Ffood[i].pos_back[0], Ffood[i].pos_back[1], Ffood[i].pos_back[0] + Ffood[i].size[0], Ffood[i].pos_back[1] + Ffood[i].size[1], WHITE);
		}
		if(Ffood[i].move_flag != 0 && Ffood[i].flag != 0) {
			Lcd_Draw_Bar(Ffood[i].pos_back[0], Ffood[i].pos_back[1], Ffood[i].pos_back[0] + Ffood[i].size[0], Ffood[i].pos_back[1] + Ffood[i].size[1], WHITE);
			Lcd_Draw_BMP(Ffood[i].pos[0],Ffood[i].pos[1],Disp[Ffood[i].image]);
			Ffood[i].move_flag = 0;
		}

	}
}

void Check1(int num) {
	int idx = Ffood[num].pos[0] / 40;
	int idx_fd = Ffood[num].image;
	if(idx ==0 || idx==1) {
		if(Bas.pos[0]>=0 && Bas.pos[0] <80) {
			if(!(idx_fd%2)) {score++; return;}
			else if (idx_fd==1 || idx_fd==5){score-=2; return;}
			else if (idx_fd==3) {score--; return;}
			else if (idx_fd==7) GameOver();
		}
		else return;
	}
	else if(idx == 2 || idx ==3) {
		if(Bas.pos[0]>=80 && Bas.pos[0] <160) {
			if(!(idx_fd%2)) {score++; return;}
			else if (idx_fd==1 || idx_fd==5){score-=2; return;}
			else if (idx_fd==3) {score--; return;}
			else if (idx_fd==7) GameOver();
				}
		else return;
	}
	else if(idx ==4 || idx == 5) {
		if(Bas.pos[0]>=160 && Bas.pos[0] <240) {
			if(!(idx_fd%2)) {score++; return;}
			else if (idx_fd==1 || idx_fd==5){score-=2; return;}
			else if (idx_fd==3) {score--; return;}
			else if (idx_fd==7) GameOver();
		}
		else return;
	}
	else {
		if(Bas.pos[0]>=240) {
			if(!(idx_fd%2)) {score++; return;}
			else if (idx_fd==1 || idx_fd==5){score-=2; return;}
			else if (idx_fd==3) {score--; return;}
			else if (idx_fd==7) GameOver();
				}
		else return;
	}

}

void Check2(int num) {
	int idx = Ffood[num].pos[0];
	int idx_fd = Ffood[num].image;
	if(idx ==Bas.pos[0]) {
			if(idx_fd>=7)GameOver();
			else if (idx_fd==1 || idx_fd==5){score-=2; return;}
			else if (idx_fd==3) {score--; return;}
			else if (!(idx_fd%2)){score++; return;}
	}
	else return;

}

void Move_Basket(int key) {

	if(key == 2) {
		if(Bas.pos[0] <= 0) {
			return;
		}
		else {
			Bas.pos_back[0] = Bas.pos[0];
			Bas.pos[0] = Bas.pos[0] - Bas.move_step;
		}
	}
	else if(key == 4) {
		if(Bas.pos[0] >= 240+bas_right[lv_cnt]) {
			return;
		}
		else {
			Bas.pos_back[0] = Bas.pos[0];
			Bas.pos[0] = Bas.pos[0] + Bas.move_step;
		}
	}
}

void Draw_Basket1(void) {

	Lcd_Draw_Bar(Bas.pos_back[0], Bas.pos_back[1], Bas.pos_back[0] + Bas.size[0], Bas.pos_back[1] + Bas.size[1], BACK_COLOR);

	if(Bas.pos[0] + Bas.size[0] >= 319) {
		Lcd_Draw_BMP(Bas.pos[0],Bas.pos[1],basket);


	}
	else {
		Lcd_Draw_BMP(Bas.pos[0],Bas.pos[1],basket);
	}

}
void Draw_Basket2(void) {
	Bas.size[0] = 40;
	Bas.move_step = 40;
	Lcd_Draw_Bar(Bas.pos_back[0], Bas.pos_back[1], Bas.pos_back[0] + Bas.size[0], Bas.pos_back[1] + Bas.size[1], BACK_COLOR);

	if(Bas.pos[0] + Bas.size[0] >= 319) {
		Lcd_Draw_BMP(Bas.pos[0],Bas.pos[1],basket2);


	}
	else {
		Lcd_Draw_BMP(Bas.pos[0],Bas.pos[1],basket2);
	}

}


void Game_Init(void)
{


	Lcd_Clr_Screen(BACK_COLOR);
	Lcd_Draw_Bar(0,220,320,240,BLACK);
	Timer0_Repeat(600);
	Lcd_Printf(5,225, BLUE, YELLOW, 1,1,"%s", "score :");
	Lcd_Printf(70,225, YELLOW,BLACK, 1,1,"%d", score);
	switch(lv_cnt) {
	case 0: Timer0_Repeat(600); Lcd_Printf(270,225, PINK, BLACK, 1,1,"%s", "LEVEL1"); break;
	case 1: Timer0_Repeat(600); Lcd_Printf(270,225, PINK, BLACK, 1,1,"%s", "LEVEL2"); break;
	case 2:	Timer0_Repeat(400); Lcd_Printf(270,225, PINK, BLACK, 1,1,"%s", "LEVEL3"); break;
	case 3: Timer0_Repeat(300); Lcd_Printf(270,225, PINK, BLACK, 1,1,"%s", "LEVEL4"); break;
	}
}


void GameOver(void) {
	Lcd_Draw_BMP(0,0,back);
	do {
			Lcd_Draw_BMP(0,0,back);
			Lcd_Printf(65,160,BLUE,YELLOW,1,1,"Try Again : ");
			Lcd_Printf(162,160,PINK,YELLOW,1,1,"Push Button");
			Led_Display(0x5);
			Timer4_Delay(100);
			Led_Display(0x6);
						Timer4_Delay(100);
						Led_Display(0x7);
									Timer4_Delay(100);
									Led_Display(0x8);
											Timer4_Delay(100);
		}while(!Key_Get_Pressed());
			lv_cnt = 0;
			Level();

}
/*
void Special_Mode_Test(void)
{


	Uart_Printf("\n그래픽 기본 함수 실습\n");
	Uart_Printf("키보드 누를때마다 다음단계로 진행\n");

	Uart_Printf("Non Transparency Mode\n");

	Lcd_Clr_Screen(BLACK);
	Lcd_Draw_Bar(0,0,100,100,RED);
	Lcd_Draw_Bar(50,50,200,200,BLUE);

	while(!Uart_Get_Pressed());

	Uart_Printf("Transparency Mode\n");

	Lcd_Clr_Screen(BLACK);
	Lcd_Set_Trans_Mode(1);
	Lcd_Draw_Bar(0,0,100,100,RED);
	Lcd_Draw_Bar(50,50,200,200,BLUE);
	Lcd_Set_Trans_Mode(0);

	while(!Uart_Get_Pressed());

	Uart_Printf("Non Shape Mode\n");

	Lcd_Clr_Screen(GREEN);



	while(!Uart_Get_Pressed());

	Uart_Printf("Shape Mode(Chroma Key Mode)\n");



	Uart_Printf("키보드 누르면 종료\n");
	while(!Uart_Get_Pressed());
}

void Font_Test(void)
{
	int i, j;
	char str[20];

	Uart_Printf("영문 Nickname(20글자 이내)");
	Uart_GetString(str);
	Uart_Printf("\nFont Display\n");
	Lcd_Printf(2,2,BLACK,RED,2,2,"윌텍 임베디드 그룹");
	Lcd_Printf(0,150,GREEN,BLACK,1,1,"%s", "(주)윌텍,(주)행복한기술");
	Lcd_Printf(0,170,GREEN,BLACK,1,1,"%s", "(주)기쁜기술,(주)임베딕스,(주)에듀닉스");
	Lcd_Printf(30,100,RED,GREEN,2,1,"윌텍은 %d개 회사", 5);
	Lcd_Printf(0,200,BLUE,GREEN,1,2,"화이팅! %s", str);

	for(i=0; i<10; i++)
	{
		for(j=0; j<10; j++)
		{
			Lcd_Put_Pixel(50+i, 80+j, BLUE);
		}
	}

	Uart_Printf("키보드 누르면 종료\n");
	while(!Uart_Get_Pressed());
}

void Brightness_Test(void)
{
	int b;

	Uart_Printf("Brightness Test\n");

	Lcd_Clr_Screen(BLACK);


	for(;;)
	{
		Uart_Printf("0 누르면 종료\n");
		Uart_Printf("밝기 입력 [1~9] => ");

		b = Uart_GetIntNum();
		if(b == 0) break;
		if(b > 9)
		{
			Uart_Printf("똑바로 눌러라 잉~\n");
			continue;
		}
		Lcd_Control_Brightness(b);
	}
}

enum key{C1, C1_, D1, D1_, E1, F1, F1_, G1, G1_, A1, A1_, B1, C2, C2_, D2, D2_, E2, F2, F2_, G2, G2_, A2, A2_, B2};
enum note{N16, N8, N4, N2, N1};
const int song[][2] = {{G1,N4},{G1,N4},{E1,N8},{F1,N8},{G1,N4},{A1,N4},{A1,N4},{G1,N2},{G1,N4},{C2,N4},{E2,N4},{D2,N8},{C2,N8},{D2,N2},{0xff, 0xff}};

void Buzzer_Test(void)
{
	//int i = 0;

//	Uart_Printf("Buzzer Test\n");

	Timer3_Buzzer_Beep(C1,N4);
	Timer3_Buzzer_Beep(D1,N4);
	Timer3_Buzzer_Beep(E1,N4);
	Timer3_Buzzer_Beep(F1,N4);
	Timer3_Buzzer_Beep(G1,N4);
	Timer3_Buzzer_Beep(A1,N4);
	Timer3_Buzzer_Beep(B1,N4);
	Timer3_Buzzer_Beep(C2,N4);

	Timer4_Delay(1000);

	while(song[i][0] != 0xff)
	{
		Timer3_Buzzer_Beep(song[i][0], song[i][1]);
		Uart_Printf(".");
		i++;
	}

	Uart_Printf("\n");
}

void Key_Test(void)
{
	int i;
	int key;

	Uart_Printf("9개의 KEY를 눌러봅시다\n");

	for(i=0; i<9; i++)
	{
		key = Key_Wait_Key_Pressed();
		Uart_Printf("Key = %d\n", key);
		Timer4_Delay(400);

		// 다음 코드의 유무에 따른 동작을 확인하라
		Key_Wait_Key_Released();
	}

	Uart_Printf("\n5번 버튼([1]) 누를때까지 계속 LED 깜박임\n");

	do
	{
		Led_Display(0x5);
		Timer4_Delay(100);
		Led_Display(0xA);
		Timer4_Delay(100);
	}while(Key_Get_Pressed() != 5);

	Uart_Printf("여러 키를 동시에 눌러 봅시다 총 5번 동작\n");
	Key_Wait_Key_Released();

	for(i=0; i<5; i++)
	{
		key = Key_Wait_Key_Pressed_Multi();
		Uart_Printf("Key = %#X\n", key);
		Timer4_Delay(400);

		Key_Wait_Key_Released_Multi();
	}

	Uart_Printf("\n5번 버튼([1])만 눌릴때까지 계속 key 상태를 표시함\n");

	do
	{
		Timer4_Delay(400);
		key = Key_Get_Pressed_Multi();
		Uart_Printf("Key = %#X\n", key);
	}while(key != 0x10);
}

void Timer_Test(void)
{
	int i;
	int r;
	int disp;

	Uart_Printf("Timer Test\n");

	Uart_Printf("Timer4_Delay\n");

	for(i=1; i<=5; i++)
	{
		Timer4_Delay(1000);
		Uart_Printf("%d\r", i);
	}

	Uart_Printf("\n");

	Uart_Printf("\nTimer1_Stopwatch\n");
	Uart_Printf("키보드 누르면 시작\n");
	while(!Uart_Get_Pressed());

	Timer4_Delay(1000);

	for(i=1; i<=5; i++)
	{
		Uart_Printf("Stopwatch Run\n");
		Timer1_Stopwatch_Run();
		Timer4_Delay(200*i);
		r = Timer1_Stopwatch_Stop();
		Uart_Printf("Elapsed Time = %d msec\r", r);
	}

	Uart_Printf("\nTimer0_Repeat(최대 1.3초)\n");
	Uart_Printf("키보드 누르면 시작\n");
	while(!Uart_Get_Pressed());

	Timer0_Repeat(500);
	disp = 0xf;

	for(i=1;;)
	{
		if(Timer0_Check_Expired())
		{
			Led_Display(disp = ~disp);
			Uart_Printf("[%d]\n", i);
			i++;
			if(i>10) break;
		}
	}

	Timer0_Stop();

	Uart_Printf("\nTimer0_Repeat => 주기 변경(최대 약 1.3초)\n");
	Uart_Printf("주기 설정이 1300msec가 넘어가면 어떻게 되는가?\n");
	Uart_Printf("키보드 누르면 시작\n");
	while(!Uart_Get_Pressed());

	Timer0_Repeat(100);
	disp = 0xf;

	for(i=1;;)
	{
		if(Timer0_Check_Expired())
		{
			Led_Display(disp = ~disp);
			Timer0_Change_Delay(100*(i+1));
			Uart_Printf("[%d] Interval=%d msec\n", i, 100*(i+1));
			i++;
			if(i>20) break;
		}
	}
}*/
