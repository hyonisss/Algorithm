/***********************************************************/
// 다음은 사용자 함수를 호출하는 루틴임 지우지 말것!
/***********************************************************/

#include "device_driver.h"
#include "math.h"
#include "2440addr.h"
#include <stdlib.h>
#define printf 	Uart_Printf

void User_Main(void);
typedef struct
{
int day;
int year;
int mon;
int date;
int hour;
int min;
int sec;
}RTC_TIME;

int RTC_Get_Time(void)
{
RTC_TIME a;

a.hour = (int)rBCDHOUR;
a.min = (int)rBCDMIN;
a.sec = (int)rBCDSEC;
return ((a.hour >> 4) & 0xf) * 10 + (a.hour & 0xf) * 360 + \
((a.min >> 4) & 0xf) * 10 + (a.min & 0xf) * 60 + \
((a.sec >> 4) & 0xf) * 10 + (a.sec & 0xf);

}
void Main(void)
{
	MMU_Init();
	Led_Init();
	Key_Poll_Init();
	Uart_Init(115200);
	Timer0_Init();
	Timer3_Buzzer_Init();
	Timer4_Init();
	Lcd_Graphic_Init();
	Lcd_Clr_Screen(0xf800);

	Uart_Printf("Welcome GBOX World!\n");
	User_Main();
	Uart_Printf("Good Bye~\n");
}

/*===== << 여기부터 사용자 프로그램을 작성함 >> =====*/

#include "./Image/img01.h"
#include "./Image/img02.h"
#include "./Image/img03.h"
#include "./Image/img04.h"
#include "./Image/img05.h"
#include "./Image/shape.h"
#include "./Image/start.h"
#include "./Image/basket.h"
const unsigned short * Disp[] = {img01, img02, img03, img04};

/* 5:5:5:I Color Definition */

#define BLACK	0x0000
#define WHITE	0xfffe
#define BLUE	0x003e
#define GREEN	0x07c0
#define RED		0xf800
#define YELLOW	0xf7c0
#define PINK 	0xf8fe

void Basic_Graphics_Test(void);
void Special_Mode_Test(void);
void Font_Test(void);
void Brightness_Test(void);
void Key_Test(void);
void Buzzer_Test(void);
void Timer_Test(void);
void Simple_Example(void);
//void Explain_Game(void);
void Level1(void);
void Game_Init();
void User_Main(void)
{
	int xtmp, ytmp;
	int r, u;
	for(;;)
	{

		Lcd_Control_Brightness(5);
		Lcd_Select_Buffer_Mode(LAYER_MODE);
	 	Lcd_Select_Draw_Frame_Buffer(0);
	 	Lcd_Select_Display_Frame_Buffer(0);
	 	Lcd_Clr_Screen(RED);
	    Lcd_Get_Info_BMP(&xtmp, &ytmp, start);
	    Lcd_Draw_BMP((160-(xtmp/2)), (120-(ytmp/2)), start);
		Lcd_Printf(120,100,YELLOW,RED,1,1,"VEGAN GAME");
		Lcd_Printf(90,130,WHITE,BLACK,1,1,"Game Start : Press 1");
		Lcd_Printf(85,150,WHITE,BLACK,1,1,"How to Play : Press 2");

					do
						{
							Led_Display(0x5);
							Timer4_Delay(100);
							Led_Display(0x6);
							Timer4_Delay(100);
						}while(!Key_Get_Pressed());
				u = Key_Wait_Key_Pressed ();
				switch(u) {
				case 5: Level1(); break;
				case 6: Font_Test(); break;
				//case 6: Explain_Game(); break;
				}

		Uart_Printf("===================================================\n");
		Uart_Printf("GBOX WT2440L API Function Test    (c)Willtek Corp. \n");
		Uart_Printf("===================================================\n");
		Uart_Printf("[1] Basic Graphics Test		                   			\n");
		Uart_Printf("[2] Special Graphics Mode Test                    	\n");
		Uart_Printf("[3] Font Display Test                            	\n");
		Uart_Printf("[4] Brightness Test                              	\n");
		Uart_Printf("[5] Buzzer Test                    								\n");
		Uart_Printf("[6] Key Test		                   									\n");
		Uart_Printf("[7] Timer Test			                            		\n");
		Uart_Printf("[8] Simple Example		                            	\n");
		Uart_Printf("===================================================\n");
		Uart_Printf(">> ");
		r =Uart_GetIntNum();
		if((unsigned int)r >= 11)
		{
			Uart_Printf("Wrong Number!\n");
			continue;
		}

		switch(r)
		{
			case 1 : Basic_Graphics_Test(); break;
			case 2 : Special_Mode_Test(); break;
			case 3 : Font_Test(); break;
			case 4 : Brightness_Test(); break;
			case 5 : Buzzer_Test(); break;
			case 6 : Key_Test(); break;
			case 7 : Timer_Test(); break;
			case 8 : Simple_Example(); break;
			default : Uart_Printf("Wrong Number!\n"); break;
		}

		Uart_Printf("Test Finished\n\n");
	}
}
#define BACK_COLOR 	BLACK
#define WIDTH 		320
#define HEIGHT 		240
struct Object1
{
	int timer;
	int move_flag;
	int pos[2];
	int pos_init[2];
	int pos_back[2];
	int size[2];
	unsigned short color;
	int speed_step;
	int move_step;
};
//0, 40, 80, 120, 160, 200 240, 280
//(rand()%8 * 40)
struct Object1 Basket = {0,1,{0,180},{0,180},{0,180}, {80, 30},WHITE, 4, 80};
struct Object1 FGreen = {0,1,{120,0},{120,0},{120,0},{40,20},GREEN, 3, 20};
struct Object1 FBlue = {0,1,{120,300},{120,300},{120,300},{40,30},BLUE, 4, 40};
struct Object1 FPink = {0,1,{150,300},{150,240},{150,240},{40,30},PINK, 4, 40};

void Move_Food(void) {
	srand(RTC_Get_Time());
	if(Timer0_Check_Expired()) {
		FGreen.timer++;
	}
	if(FGreen.timer >= FGreen.speed_step) {
		FGreen.timer = 0;
		FGreen.pos[0] = rand() % 8 * 40;
		FGreen.pos_back[1] = FGreen.pos[1] ;
		FGreen.pos[1] = FGreen.pos[1] + FGreen.move_step;
		FGreen.move_flag = 1;
	}
}
void Move_Basket(int key) {

	if(key == 2) {
		if(Basket.pos[0] <= 0) {
			return;
		}
		else {
			Basket.pos_back[0] = Basket.pos[0];
			Basket.pos[0] = Basket.pos[0] - Basket.move_step;
		}
	}
	else if(key == 4) {
		if(Basket.pos[0] >= 240) {
			return;
		}
		else {
			Basket.pos_back[0] = Basket.pos[0];
			Basket.pos[0] = Basket.pos[0] + Basket.move_step;
		}
	}
}
void Draw_Food(void) {
	if(FGreen.pos[1] > 180) {
		FGreen.pos[1] = FGreen.pos_init[1];
	}
	if(FGreen.move_flag != 0) {
		Lcd_Draw_Bar(FGreen.pos_back[0], FGreen.pos_back[1], FGreen.pos_back[0] + FGreen.size[0], FGreen.pos_back[1] + FGreen.size[1], BACK_COLOR);
		Lcd_Draw_Bar(FGreen.pos[0], FGreen.pos[1], FGreen.pos[0] + FGreen.size[0], FGreen.pos[1] + FGreen.size[1], GREEN);
		FGreen.move_flag = 0;
	}
}
void Draw_Basket(void) {

	if(Basket.pos[0] >= 240) { //화면 밖 바구니 벗어남 방지(오른쪽 이동)
	//	Uart_Printf("%d\n", Basket.pos[0]);
		Lcd_Draw_Bar(0, 180,100, Basket.pos_back[1] + Basket.size[1], BACK_COLOR);
		Lcd_Draw_Bar(240, 180, 320, 180 + Basket.size[1], Basket.color);


	}
	if(Basket.pos[0] <0 ) { //화면 밖 바구니 벗어남 방지(오른쪽 이동)
		Lcd_Draw_Bar(240, 320,80, Basket.pos_back[1] + Basket.size[1], BACK_COLOR);
		Lcd_Draw_Bar(0, 180, Basket.size[0], 180 + Basket.size[1], Basket.color);

	}
	else {
		Lcd_Draw_Bar(Basket.pos_back[0], Basket.pos_back[1], Basket.pos_back[0] + Basket.size[0], Basket.pos_back[1] + Basket.size[1], BACK_COLOR);
		Lcd_Draw_Bar(Basket.pos[0], Basket.pos[1], Basket.pos[0] + Basket.size[0], Basket.pos[1] + Basket.size[1], Basket.color);
	}

}
void Level1(void) {
		int key;
		Game_Init();
		Draw_Food();
		Draw_Basket(); // 처음 바구니 그리기
		for(;;) {
			Move_Food();
			Draw_Food();
			key = Key_Get_Pressed();
			if(key) {
				Move_Basket(key);
				Draw_Basket();
				Key_Wait_Key_Released();
			}
		}

}
void Basic_Graphics_Test(void)
{
	int i;
	int xtmp, ytmp;

	Uart_Printf("\n그래픽 기본 함수 실습\n");
	Uart_Printf("키보드 누를때마다 다음단계로 진행\n");
	Lcd_Get_Info_BMP(&xtmp, &ytmp, start);
	Uart_Printf("x size : %d, y size :%d\n", xtmp, ytmp);



	while(!Uart_Get_Pressed());

	Uart_Printf("Clear Screen\n");
	Lcd_Clr_Screen(BLUE);

	while(!Uart_Get_Pressed());

	Uart_Printf("Draw HLINE, VLINE, LINE\n");
	Lcd_Draw_Hline(100,50,200,RED);
	Lcd_Draw_Vline(80,100,200,RED);
	Lcd_Draw_Line(0,0,319,239,GREEN);

	while(!Uart_Get_Pressed());

	Uart_Printf("Draw Rectangular\n");
	Lcd_Clr_Screen(BLACK);
	Lcd_Draw_Rect(20,20,120,120,RED);
	Lcd_Draw_Rect(70,70,220,220,BLUE);

	while(!Uart_Get_Pressed());

	Uart_Printf("Draw BAR\n");
	Lcd_Clr_Screen(BLACK);
	Lcd_Draw_Bar(0,0,100,100,RED);
	Lcd_Draw_Bar(50,50,200,200,BLUE);

	while(!Uart_Get_Pressed());

	Uart_Printf("Draw BMP\n");
	Uart_Printf("Get BMP Information\n");
	Lcd_Get_Info_BMP(&xtmp, &ytmp, img01);
	Uart_Printf("X=[%d], Y=[%d]\n", xtmp, ytmp);
	Lcd_Draw_BMP((160-(xtmp/2)), (120-(ytmp/2)), img01);

	for(i=0; i<(sizeof(Disp)/sizeof(Disp[0])); i++)
	{
		Lcd_Get_Info_BMP(&xtmp, &ytmp, Disp[i]);
		Uart_Printf("X=[%d], Y=[%d]\n", xtmp, ytmp);
		Lcd_Draw_BMP((160-(xtmp/2)), (120-(ytmp/2)), Disp[i]);
		Timer4_Delay(1000);
	}

	Uart_Printf("키보드 누르면 종료\n");
	while(!Uart_Get_Pressed());
}

void Special_Mode_Test(void)
{
	int xtmp, ytmp;

	Uart_Printf("\n그래픽 기본 함수 실습\n");
	Uart_Printf("키보드 누를때마다 다음단계로 진행\n");

	Uart_Printf("Non Transparency Mode\n");

	Lcd_Clr_Screen(BLACK);
	Lcd_Draw_Bar(0,0,100,100,RED);
	Lcd_Draw_Bar(50,50,200,200,BLUE);

	while(!Uart_Get_Pressed());

	Uart_Printf("Transparency Mode\n");

	Lcd_Clr_Screen(BLACK);
	Lcd_Set_Trans_Mode(1);
	Lcd_Draw_Bar(0,0,100,100,RED);
	Lcd_Draw_Bar(50,50,200,200,BLUE);
	Lcd_Set_Trans_Mode(0);

	while(!Uart_Get_Pressed());

	Uart_Printf("Non Shape Mode\n");

	Lcd_Clr_Screen(GREEN);
    Lcd_Get_Info_BMP(&xtmp, &ytmp, shape);
    Lcd_Draw_BMP((160-(xtmp/2)), (120-(ytmp/2)), shape);

	while(!Uart_Get_Pressed());

	Uart_Printf("Shape Mode(Chroma Key Mode)\n");

    Lcd_Set_Shape_Mode(1,0xFFFE);
	Lcd_Clr_Screen(GREEN);
    Lcd_Get_Info_BMP(&xtmp, &ytmp, shape);
    Lcd_Draw_BMP((160-(xtmp/2)), (120-(ytmp/2)), shape);
    Lcd_Set_Shape_Mode(0,0);

	Uart_Printf("키보드 누르면 종료\n");
	while(!Uart_Get_Pressed());
}

void Font_Test(void)
{
	int i, j;
	char str[20];

	Uart_Printf("영문 Nickname(20글자 이내)");
	Uart_GetString(str);
	Uart_Printf("\nFont Display\n");
	Lcd_Printf(2,2,BLACK,RED,2,2,"윌텍 임베디드 그룹");
	Lcd_Printf(0,150,GREEN,BLACK,1,1,"%s", "(주)윌텍,(주)행복한기술");
	Lcd_Printf(0,170,GREEN,BLACK,1,1,"%s", "(주)기쁜기술,(주)임베딕스,(주)에듀닉스");
	Lcd_Printf(30,100,RED,GREEN,2,1,"윌텍은 %d개 회사", 5);
	Lcd_Printf(0,200,BLUE,GREEN,1,2,"화이팅! %s", str);

	for(i=0; i<10; i++)
	{
		for(j=0; j<10; j++)
		{
			Lcd_Put_Pixel(50+i, 80+j, BLUE);
		}
	}

	Uart_Printf("키보드 누르면 종료\n");
	while(!Uart_Get_Pressed());
}

void Brightness_Test(void)
{
	int b;

	Uart_Printf("Brightness Test\n");

	Lcd_Clr_Screen(BLACK);
	Lcd_Draw_BMP(0,0,img01);

	for(;;)
	{
		Uart_Printf("0 누르면 종료\n");
		Uart_Printf("밝기 입력 [1~9] => ");

		b = Uart_GetIntNum();
		if(b == 0) break;
		if(b > 9)
		{
			Uart_Printf("똑바로 눌러라 잉~\n");
			continue;
		}
		Lcd_Control_Brightness(b);
	}
}

enum key{C1, C1_, D1, D1_, E1, F1, F1_, G1, G1_, A1, A1_, B1, C2, C2_, D2, D2_, E2, F2, F2_, G2, G2_, A2, A2_, B2};
enum note{N16, N8, N4, N2, N1};
const int song[][2] = {{G1,N4},{G1,N4},{E1,N8},{F1,N8},{G1,N4},{A1,N4},{A1,N4},{G1,N2},{G1,N4},{C2,N4},{E2,N4},{D2,N8},{C2,N8},{D2,N2},{0xff, 0xff}};

void Buzzer_Test(void)
{
	//int i = 0;

//	Uart_Printf("Buzzer Test\n");

	Timer3_Buzzer_Beep(C1,N4);
	Timer3_Buzzer_Beep(D1,N4);
	Timer3_Buzzer_Beep(E1,N4);
	Timer3_Buzzer_Beep(F1,N4);
	Timer3_Buzzer_Beep(G1,N4);
	Timer3_Buzzer_Beep(A1,N4);
	Timer3_Buzzer_Beep(B1,N4);
	Timer3_Buzzer_Beep(C2,N4);

	Timer4_Delay(1000);

/*	while(song[i][0] != 0xff)
	{
		Timer3_Buzzer_Beep(song[i][0], song[i][1]);
		Uart_Printf(".");
		i++;
	}
*/
	Uart_Printf("\n");
}

void Key_Test(void)
{
	int i;
	int key;

	Uart_Printf("9개의 KEY를 눌러봅시다\n");

	for(i=0; i<9; i++)
	{
		key = Key_Wait_Key_Pressed();
		Uart_Printf("Key = %d\n", key);
		Timer4_Delay(400);

		// 다음 코드의 유무에 따른 동작을 확인하라
		Key_Wait_Key_Released();
	}

	Uart_Printf("\n5번 버튼([1]) 누를때까지 계속 LED 깜박임\n");

	do
	{
		Led_Display(0x5);
		Timer4_Delay(100);
		Led_Display(0xA);
		Timer4_Delay(100);
	}while(Key_Get_Pressed() != 5);

	Uart_Printf("여러 키를 동시에 눌러 봅시다 총 5번 동작\n");
	Key_Wait_Key_Released();

	for(i=0; i<5; i++)
	{
		key = Key_Wait_Key_Pressed_Multi();
		Uart_Printf("Key = %#X\n", key);
		Timer4_Delay(400);

		Key_Wait_Key_Released_Multi();
	}

	Uart_Printf("\n5번 버튼([1])만 눌릴때까지 계속 key 상태를 표시함\n");

	do
	{
		Timer4_Delay(400);
		key = Key_Get_Pressed_Multi();
		Uart_Printf("Key = %#X\n", key);
	}while(key != 0x10);
}

void Timer_Test(void)
{
	int i;
	int r;
	int disp;

	Uart_Printf("Timer Test\n");

	Uart_Printf("Timer4_Delay\n");

	for(i=1; i<=5; i++)
	{
		Timer4_Delay(1000);
		Uart_Printf("%d\r", i);
	}

	Uart_Printf("\n");

	Uart_Printf("\nTimer1_Stopwatch\n");
	Uart_Printf("키보드 누르면 시작\n");
	while(!Uart_Get_Pressed());

	Timer4_Delay(1000);

	for(i=1; i<=5; i++)
	{
		Uart_Printf("Stopwatch Run\n");
		Timer1_Stopwatch_Run();
		Timer4_Delay(200*i);
		r = Timer1_Stopwatch_Stop();
		Uart_Printf("Elapsed Time = %d msec\r", r);
	}

	Uart_Printf("\nTimer0_Repeat(최대 1.3초)\n");
	Uart_Printf("키보드 누르면 시작\n");
	while(!Uart_Get_Pressed());

	Timer0_Repeat(500);
	disp = 0xf;

	for(i=1;;)
	{
		if(Timer0_Check_Expired())
		{
			Led_Display(disp = ~disp);
			Uart_Printf("[%d]\n", i);
			i++;
			if(i>10) break;
		}
	}

	Timer0_Stop();

	Uart_Printf("\nTimer0_Repeat => 주기 변경(최대 약 1.3초)\n");
	Uart_Printf("주기 설정이 1300msec가 넘어가면 어떻게 되는가?\n");
	Uart_Printf("키보드 누르면 시작\n");
	while(!Uart_Get_Pressed());

	Timer0_Repeat(100);
	disp = 0xf;

	for(i=1;;)
	{
		if(Timer0_Check_Expired())
		{
			Led_Display(disp = ~disp);
			Timer0_Change_Delay(100*(i+1));
			Uart_Printf("[%d] Interval=%d msec\n", i, 100*(i+1));
			i++;
			if(i>20) break;
		}
	}
}

#define BACK_COLOR 	BLACK
#define WIDTH 		320
#define HEIGHT 		240

struct Object
{
	int timer;
	int move_flag;
	int pos[2];
	int pos_init[2];
	int pos_back[2];
	int size[2];
	unsigned short color;
	int speed_step; //어떤 시간간격으로 이전거를 지우고 새로 그릴건지
	int move_step;	//움직임의 거리 간격
};

struct Object Ufo = {0,1,{0,10},{0,10},{0,10},{30,10},RED, 3, 8};
struct Object Gun = {0,1,{160,300},{160,300},{160,300},{10,30},BLUE, 1, 10};

void Move_Object(void)
{
	if(Timer0_Check_Expired())
	{
		Ufo.timer++;
		Gun.timer++;

		if(Ufo.timer >= Ufo.speed_step)
		{
			Ufo.timer = 0;
			Ufo.pos_back[0] = Ufo.pos[0]; // 현재 포지션 백에 넣기
			Ufo.pos[0] = Ufo.pos[0] + Ufo.move_step;
			Ufo.move_flag = 1;
		}

		if(Gun.timer >= Gun.speed_step)
		{
			Gun.timer = 0;
			Gun.pos_back[1] = Gun.pos[1];
			Gun.pos[1] = Gun.pos[1] - Gun.move_step;
			Gun.move_flag = 1;
		}
	}
}

void Draw_Object(void)
{
	if((Ufo.pos[0] >= WIDTH))
	{
		Ufo.pos[0] = Ufo.pos_init[0];
	}

	if((Gun.pos[1] < 0))
	{
		Gun.pos[1] = Gun.pos_init[1];
	}

	if(Ufo.move_flag != 0) //move flag : 그릴 위치가 바껴서 그 위치에 그림을 그려야 해
	{
		Lcd_Draw_Bar(Ufo.pos_back[0], Ufo.pos_back[1], Ufo.pos_back[0] + Ufo.size[0], Ufo.pos_back[1] + Ufo.size[1], BACK_COLOR); //이전꺼 지우기
		Lcd_Draw_Bar(Ufo.pos[0], Ufo.pos[1], Ufo.pos[0] + Ufo.size[0], Ufo.pos[1] + Ufo.size[1], Ufo.color); // 새로 그리기
		Ufo.move_flag = 0;
	}
	if(Gun.move_flag != 0)
	{
		Lcd_Draw_Bar(Gun.pos_back[0], Gun.pos_back[1], Gun.pos_back[0] + Gun.size[0], Gun.pos_back[1] + Gun.size[1], BACK_COLOR);
		Lcd_Draw_Bar(Gun.pos[0], Gun.pos[1], Gun.pos[0] + Gun.size[0], Gun.pos[1] - Gun.size[1], Gun.color);
		Gun.move_flag = 0;
	}
}

void Game_Init(void)
{
	Lcd_Clr_Screen(BACK_COLOR);
	Timer0_Repeat(500);
}

void Simple_Example(void)
{
	Game_Init();
	Draw_Object();

	for(;;)
	{
		Move_Object();
		Draw_Object();
	}
}

